
##### Table of Contents..
[Часть 1 - Symfony2 Конфигурация и Шаблоны](#Часть 1 - Symfony2 Конфигурация и Шаблоны)
[Часть 2 - Страница контактов: Валидаторы, Формы и Отправка](#Часть 2 - Страница контактов: Валидаторы, Формы и Отправка)
[Часть 3 - Модель Блога: Использование Doctrine 2 и Data Fixtures](Часть 3 - Модель Блога: Использование Doctrine 2 и Data Fixtures)
[Часть 4 - Модель Комментариев: Добавление комментариев, Doctrine Хранилища и Миграции](#Часть 4 - Модель Комментариев: Добавление комментариев, Doctrine Хранилища и Миграции)
[Часть 5 - Настройка вида: Twig расширения, Боковая панель и Ресурсы](#Часть 5 - Настройка вида: Twig расширения, Боковая панель и Ресурсы)
[Часть 6 - Тестирование: Unit и Функционал с PHPUnit](#Часть 6 - Тестирование: Unit и Функционал с PHPUnit)
[Часть 7 - Формирование административной панели при помощи пакета Sonata Admin Bundle](#Часть 7 - Формирование административной панели при помощи пакета Sonata Admin Bundle)
[Преимущества Twig](#Преимущества Twig)
[SonataAdminBundle](#SonataAdminBundle)
[Пакет FOSUser](#Пакет FOSUser)
[Связь Многие-Ко-Многим с дополнительными полями Формы в Symfony2](#Связь Многие-Ко-Многим с дополнительными полями Формы в Symfony2)
[SonataProject-NewsBundle](#SonataProject-NewsBundle)
[SonataProject-MediaBundle](#SonataProject-MediaBundle)
[SyliusProductBundle](#SyliusProductBundle)
[SyliusCartBundle](#SyliusCartBundle)


##Связь Многие-Ко-Многим с дополнительными полями Формы в Symfony2

## Symfony 2: связь многие-ко-многим и элементы формы

Одна из вещей, развивающая любовь к с Symfony2, это то, как Doctrine, формы и Twig работают вместе и в довольно элегантной манере. При помощи малой части кода в шаблоне и аннотаций вы можете поручить Symfony2 выполнение большого объема тяжелой работы и избавиться от неприятностей. Одним из таких аспектов в разработке является построение связи многие-ко-многим и последующее внедрение соответствующего кода в формы. Вопрос о том, как Symfony2 может позволить избежать болезненных моментов и обеспечить правильной техникой, может побудить вас сделать небольшое исследование в Интернете. То, что я хотел бы сделать, это обобщить мой способ борьбы с этой проблемой в одной статье.

Вопрос о связи многие-ко-многим является очень распространенной проблемой в разработке. Не вдаваясь в детали теории нормализации базы данных, я хочу сказать, что различные ORMы имеют свои собственные методы для обработки отображений и поиска. Иногда вы в конечном итоге имеете дело со сложными извлечениями и сохранениями данных. В случае с Symfony2 и Doctrine большая часть работы может быть выполнена при помощи настроек. Я в основном просто использую метод аннотаций, чтобы мой код находился в одном месте. Итак, рссмотрим пример.

В моем примере будет два типа сущностей: races (гонки) и classes (классы) (пример взят из ролевой игры). В данном случае много гонок могут принадлежать к определенному классу и вы также можете назначать для множества классов разные гонки. Все это работает в системе и с целью проверки я сформулирую сначала определение допустимых гонок для данного класса. Главным в ассоциативной связи многие-ко-многим является связь/присоединение таблицы.

В Symfony2/Doctrine вы можете использовать двустороннюю связь многие-ко-многим, чтобы справиться с данной задачей. Ниже приводится код для класса Wclass:
~~~php
<?php
namespace Kwpro\VguildBundle\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;

/**
 * 
 * @ORM\Entity(repositoryClass="Kwpro\VguildBundle\Entity\WclassRepository")
 * @ORM\Table(name="wclasses")
 */
class Wclass extends Base
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    protected $id;

    /**
     * @Assert\NotBlank()
     * @Assert\Length(
     *     min = "2",
     *  max = "150"
     * )
     * @ORM\Column(type="string", length=150)
     * 
     */    
    protected $name;

    /**
     * Двусторонняя связь - множество классов имеют множество избранных гонок (это сторона владельца)
     *
     * @ORM\ManyToMany(targetEntity="Race", inversedBy="wclasses") // Связь с родительской сущностью для сущности Race
     * @ORM\JoinTable(name="wclass_races")
     */
    protected $races;
    // Прямая сторона(сторона владельца) Wclass двустороннего отношения ссылается на обратную сторону Race при помощи атрибута inversedBy
    // Атрибут inversedBy указывает на поле wclasses сущности Race, которое является обратной стороной отношения.
    // Сторона Wclass, которая определяет @JoinTable и/или не использует атрибут mappedBy, по умолчанию использует присоединенную таблицу wclass_races
    public function __construct()
    {
        $this->races = new ArrayCollection();
    }
 // ... дополнительный код для методов getter/setter
}
~~~

Главное здесь, это аннотации над свойством $races. $races будет содержать связанные с Race (Гонка) объекты. Как видите, связь определяется как многие-ко-многим (many-to-many) при помощи первой аннотации (важно включать @ORM\часть, поскольку иначе можете столкнуться с ошибкой при запуске консольной команды для создания объектов). Атрибут inversedBy содержит название свойства wclasses родительского класса Race, и информирует о том, что свойство $wclasses будет использовано при перемещении по связи в обратном направлении. В качестве целевой сущности будем использовать entity/model класс (Race).

Наконец, у нас есть промежуточная JoinTable - таблица, которая будет использоваться и/или автоматически сгенерируется как связь/присоединение между этими двумя отношениями. Поскольку у нас нет заранее приготовленной схемы базы данных, которая содержит присоединенную таблицу, будем использовать команды diff и migrate для создания таблиц. После выполнения этих команд вы увидите, что в базе данных будет сгенерирована простая таблица под названием, хранящимся в атрибуте 'name' JoinTable аннотации и содержащей два столбца, соответственно идентификаторам id двух сущностей. Причем названия столбцов будут состоять из имени класса + первичного ключа (wclass_id и race_id).

Теперь, когда мы ознакомились с сущностью Wclass, перейдем к сущности Race, соотвествующей другой части связи:

Entity\Race.php

~~~php
<?php
namespace Kwpro\VguildBundle\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;

/**
 * 
 * @ORM\Entity(repositoryClass="Kwpro\VguildBundle\Entity\RaceRepository")
 * @ORM\Table(name="races")
 */
class Race extends Base
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    protected $id;

    /**
     * @Assert\NotBlank()
     * @Assert\Length(
     *     min = "2",
     *  max = "150"
     * )
     * @ORM\Column(type="string", length=150)
     * 
     */
    protected $name;

    /**
     * 
     * @Assert\NotBlank()
     * @Assert\Length(
     *     min = "1",
     *  max = "1"
     * )
     * @Assert\Choice(choices = {"a", "h"}, message = "Choose a valid faction." )
     * @ORM\Column(type="string", length=1)
     */
    protected $faction;

    /**
     * @ORM\ManyToMany(targetEntity="Wclass", mappedBy="races") 
     */
    protected $wclasses;
    // Обратная сторона Race отношения ссылается на основную сторону Wclass с помощью атрибута mappedBy
    // Атрибут mappedBy указывает на поле races сущности Wclass, которое является "владельцем" этого отношения (и это поле races расположено на "противоположном" конце связи)
    // Атрибут mappedBy применяется только на обратной стороне
     
    public function __construct()
    {
        $this->wclasses = new ArrayCollection();
    }
// ... Методы getter и setter.
}
~~~

Итак снова сосредоточимся на аспектах отношения. Переменная $wclasses, являющаяся значением атрибута inversedBy (который мы упоминали ранее в разделе "inversedBy" аннотации ManyToMany), будет собирать экземпляры объектов сущности Wclass. Здесь мы опять же используем аннотацию ManyToMany, но с атрибутом mappedBy, который связан с полем "races" сущности Wclass. Дополнительная таблица JoinTable здесь не определяется.

После запуска генератора сущностей и diff/migrate команд вы увидите классы, украшенные различными setters/getters методами для этих полей, такими, как добавление/удаление экземпляров сущностей в/из коллекции. На данном этапе, я не чувствую необходимости иметь дело с понятием владельца сущности. Так что я в данный момент пропущу эту часть (и, возможно, напишу об этом в будущей статье).

Важным является то, что большая часть отображения отношений и настройка структуры таблицы базы данных завершена. Тем самым было продемонстрировано, насколько легкой является эта часть Doctrine и как действительно проста и удивительна эта система! Единственно, что нам действительно необходимо сделать с точки зрения кодирования, это добавить поле ($races или $wclasses), некоторые аннотации, описывающие отношения, конструктор, который создает эти поля и импортировать все связанные объекты классов. В реальности не так уж и много работы по сравнению с другими системами! Более того, все очень логично и элегантно описано.

Определив связь для обеих классов, необходимо еще что-то с ними сделать. В качестве аргумента, скажем, что данные для races уже существуют. В случае игры в RPG (Role-Playing Game) стиле (где важную роль играет скорость реакции игрока, в данном случае World Of Warcraft), мы будем иметь данные, такие как люди, великаны, гномы, кровавые эльфы и т.п. Далее, нам необходимо назначить им классы. Дело в том, что вы должны были бы настроить части race до части класса, и именно поэтому я действительно не хочу иметь дело с понятием владельца объекта. Там могут быть будущие варианты использования, где классы не имеют ничего общего с race....

Далее определим, какие races принадлежат к какому классу в классе для создания формы. Лучший способ сделать это через класс формы. Ниже приведен код для объекта WclassType.php:

~~~php
<?php
namespace Kwpro\VguildBundle\Form;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;

class WclassType extends AbstractType
{
    public function buildForm(FormBuilderInterface $b, array $options)
    {
            $b->add('name', 'text', array(
                'attr' => array('class' => 'form_input'),
                'label' => 'Class',
                'label_attr' => array('class' => 'form_label')    
            ))
            ->add('races', 'entity', array(
                'class' => 'Kwpro\VguildBundle\Entity\Race',
                'property' => 'name',
                'multiple' => true,
                'expanded' => true
              ))
            ->add('save', 'submit')
            ->add('saveAndAdd', 'submit');
    }

    public function getName()
    {
        return 'wclass';
    }
}
~~~

 Интересно посмотреть на то место, где я добавляю класc Race. Первое, что нужно заметить, что мы используем свойство "races" сущности Wclass, которое является атрибутом, и которое вытаскивает из объекта Wclass с целью отображения этих данных в форме. Тип является "объектом", поскольку мы будет генерировать список races, связанных с классом. В части "class" необходимо указать полное пространство имен/путь, чтобы избежать ошибки при нахождении класса. "Свойство" является элементом объекта класса, и отображается при помощи этого объекта, в данном случае, мне просто нужно, вывести имена race’ов (например, кровавый эльф, карлик и т.д.). Свойство 'multiple' (множественный) означает, что мы можем выбрать один или более элементов в списке, одним словом, это способ, предоставляющий возможность сохранить более одного элемента при помощи формы для связи типа многие-ко-многим. Наконец, мы установили параметр 'expanded' в значение true (истину), так что у нас будет горизонтально расположенный набор флажков для выбора необходимых элементов (в противном случае будет создан уродливый раскрывающийся список для выбора, который будет выглядеть здесь не очень хорошо).

При использовании формы по умолчанию вы увидите просто название и горизонтальный список из чекбоксов, отображающий возможные races. Я внес некоторые улучшения в шаблон для данного случая, поскольку я оставил горизонтально расположенные чекбоксы, которые выглядят ужасно, поэтому я хотел бы перейти к вертикальному списку. Ниже представлен фрагмент из twig шаблона:

~~~php
{# index.html.twig' #}
{% extends 'KwproVguildBundle:Admin:manage.html.twig' %}

{% block form %}
    {{ form_row(form.name) }}
    <div>
        <ul>
        {% for r in form.races %}
            <li>
                {{ form_widget(r) }}
                {{ form_label(r) }}
            </li>
        {% endfor %}    
        </ul>
    </div>
{% endblock %}
~~~

Ключевой частью в этом блоке кода явдяется необычное использование ul/li элементов для создания вертикального списка. Вы можете использовать в дальнейшем CSS для улучшения внешнего вида, но я нахожу мой способ довольно неплохим. form.races генерируются из класса формы, определенного перед этим, и доступны через атрибут 'races'. Есть один недостаток в использовании этой формы, это упорядочение списка по дате создания. Если вы нуждаетесь в специфической сортировке, должны передать некоторые значения для дополнительных опций для получения желаемого вида списка.

Так как насчет сохраннения этих данных? Рутинное сохранение соответствующих данных с точки зрения Symfony2 довольно бессмысленно, что является еще одним отличным поводом, чтобы использовать Symfony2. Вместо того, чтобы перебирать все элементы и сохранять их один за другим, а также придумывать некоторые неприятные правила для формы с целью сохранения связей, Symfony2 будет обрабатывать все за кулисами (если вам не нужно делать что-то конкретное). Для меня в этом примере ничего особенного и не нужно, так что пусть Symfony2 упорно все обработает для меня. Я покажу мой метод сохранения save и объясню его:

~~~php
<?php
public function saveAction(Request $request)
    {
        $this->_addHelper();
        $id = $request->get('id');
        if ($id){
            return $this->_update($id, $request);
        }
        $f = $this->createForm($this->_formService, $this->_model);
        $f->handleRequest($request);
        $success = false;
        $data = array('success' => 0);
        if ($f->isValid())
        {
            $manager = $this->getDoctrine()->getManager();
            $manager->persist($this->_model);
            $manager->flush();
            $data['success'] = 1;
            $data['html'] = $this->renderView($this->_editRowView, array('r' => $this->_model, 'editpath' => $this->_makePath(), 'editKey' => $this->_editLinkKey));
        }
        return $this->_json($data);
    }

~~~
Там могут быть некоторые странные обозначения и очень странно именованные переменные (потому что я попытался использовать базовый класс, который будет обрабатывать 99% моих CRUD операций), но даже без специфических названий вы все равно можете использовать эту идею. Если вы видели примеры кода для сохранения формы/объектов в Symfony2, вы не могли не заметить, что в большинстве таких случаев код не сильно отличается. Обычно методы CreateForm и handleRequest находятся там, где будет происходить тяжелая работа по извлечению данных из запроса и заполнение вашей модели, т.е. за кадром. Что касается связи многие-ко-многим, то этот случай обрабатывается также. $this->_formService это просто способ указать на класс формы WclassType, определенный ранее, за исключением использования отображения из файла конфигурации services.yml, а $this->_model только экземпляр объекта класса Wclass (экземпляр класса создается при помощи _addHelper() метода). Если форма валидна, то сохраняем данные при помощи выражения $manager->persist($this->_model).

Не один раз в этом коде придется перебирать какой-то странно названный элемент формы, класть его в массив и осуществлять другие действия. Всего довольно много автоматизировано в коробке, и это здорово. Если все работает, и когда вы идете и изучаете ваши таблицы, то видите, что они теперь заполняется правильными данными. И когда вы повторно их загружаете во время редактирования, данные извлекаются автоматически еще раз.

Приятным с этой точки зрения является то, что, если у вас есть сущность и форма, которые не имеют связей, и, если позже вы добавите их, то вам не придется многое менять в плане сохранения данных. Большинство вашего кода будет уже готово на уровне сущности, формы и шаблонов. И вы должны признать, что это довольно приятно.

[link](https://web.archive.org/web/20150424001432/http://symfony.in.ua/symfony2-many-to-many-relationships-and-form-elements.html) 